# API Action Configuration

## Datasource Configuration

**CRITICAL:** Always use `bonita-api-plugin`, NEVER `restapi-plugin`.

```json
{
  "datasourceConfiguration": {"url": "/bonita/API"},
  "name": "Bonita API",
  "pluginId": "bonita-api-plugin",
  "messages": [],
  "isAutoGenerated": false,
  "id": "Bonita API",
  "gitSyncId": "unique_datasource_id",
  "deleted": false
}
```

### Key Datasource Properties

| Property | Required Value | Notes |
|----------|---------------|-------|
| `pluginId` | `"bonita-api-plugin"` | NOT `"restapi-plugin"` -- causes AE-DTS-4013 |
| `url` | `"/bonita/API"` | Base URL for all API calls |
| `id` | `"Bonita API"` | Referenced by all actions |

## API Action Structure

Complete structure for a Bonita API action:

```json
{
  "pluginType": "API",
  "pluginId": "bonita-api-plugin",
  "unpublishedAction": {
    "name": "getMyData",
    "datasource": {
      "name": "Bonita API",
      "pluginId": "bonita-api-plugin",
      "messages": [],
      "isAutoGenerated": false,
      "id": "Bonita API",
      "deleted": false,
      "policyMap": {},
      "policies": [],
      "userPermissions": []
    },
    "pageId": "Page1",
    "actionConfiguration": {
      "timeoutInMillisecond": 10000.0,
      "paginationType": "NONE",
      "path": "/extension/my/endpoint",
      "headers": [],
      "autoGeneratedHeaders": [],
      "encodeParamsToggle": true,
      "queryParameters": [
        {"key": "param1", "value": "value1"}
      ],
      "body": "",
      "bodyFormData": [],
      "httpMethod": "GET",
      "httpVersion": "HTTP11",
      "selfReferencingDataPaths": [],
      "pluginSpecifiedTemplates": [{"value": true}],
      "formData": {"apiContentType": "none"}
    },
    "runBehaviour": "ON_PAGE_LOAD",
    "dynamicBindingPathList": [],
    "isValid": true,
    "invalids": [],
    "messages": [],
    "jsonPathKeys": [],
    "userSetOnLoad": false,
    "confirmBeforeExecute": false,
    "policyMap": {},
    "userPermissions": []
  },
  "publishedAction": {
    "...same structure as unpublishedAction..."
  },
  "gitSyncId": "unique_action_id",
  "id": "Page1_getMyData",
  "deleted": false
}
```

## Critical Fields Explained

### pluginType and pluginId

```json
"pluginType": "API",
"pluginId": "bonita-api-plugin"
```

Both the action-level `pluginId` and the nested `datasource.pluginId` must be `"bonita-api-plugin"`.

### httpVersion

```json
"httpVersion": "HTTP11"
```

Must be `"HTTP11"`. Other values may cause connection issues with the Bonita server.

### formData

```json
"formData": {"apiContentType": "none"}
```

Required field. Must include `apiContentType: "none"` for standard GET/POST requests.

### autoGeneratedHeaders

```json
"autoGeneratedHeaders": []
```

Must be an empty array. Do not let the system auto-generate headers.

### selfReferencingDataPaths

```json
"selfReferencingDataPaths": []
```

Must be an empty array.

## runBehaviour

```json
"runBehaviour": "ON_PAGE_LOAD"
```

**Important:** UIB uses `runBehaviour` (NOT `executeOnLoad: true`). The value is always `"ON_PAGE_LOAD"` for queries that should load on page initialization.

For actions that should only run on user interaction, omit `runBehaviour` or set it appropriately, and do NOT include the action in `layoutOnLoadActions`.

## Action ID Format

```
PageId_actionName
```

Examples:
- `Page1_getDashboardKpis`
- `Page1_userQuery`
- `Page1_logoUrlQuery`
- `Page1_updateCustomer`

The `id` at the top level of the action object must follow this format.

## layoutOnLoadActions Batching

Controls which queries run on page load and in what order.

### Parallel Execution (Same Array)

Actions in the **same inner array** run in **parallel**:

```json
"layoutOnLoadActions": [
  [
    {"id": "Page1_getDashboardKpis"},
    {"id": "Page1_userQuery"},
    {"id": "Page1_logoUrlQuery"}
  ]
]
```

All three queries fire simultaneously.

### Sequential Execution (Different Arrays)

Actions in **different inner arrays** run **sequentially** (each batch waits for the previous to complete):

```json
"layoutOnLoadActions": [
  [
    {"id": "Page1_userQuery"},
    {"id": "Page1_logoUrlQuery"}
  ],
  [
    {
      "id": "Page1_JSInit.init",
      "name": "JSInit.init",
      "collectionId": "Page1_JSInit",
      "confirmBeforeExecute": false,
      "pluginType": "JS",
      "jsonPathKeys": [],
      "timeoutInMillisecond": 10000
    }
  ]
]
```

**Batch 1:** `userQuery` and `logoUrlQuery` run in parallel.
**Batch 2:** `JSInit.init()` runs AFTER batch 1 completes.

### Why Batching Matters

```
WRONG (race condition):
layoutOnLoadActions: [[userQuery, JSInit.init]]
  -> Both run in parallel
  -> JSInit reads userQuery.data before it is loaded
  -> Result: "Welcome User" instead of actual name

CORRECT:
layoutOnLoadActions: [[userQuery], [JSInit.init]]
  -> userQuery completes first
  -> JSInit reads loaded data
  -> Result: "Welcome walter.bates"
```

### JS Function Entry in layoutOnLoadActions

When adding a JS function to page load actions, include these fields:

```json
{
  "id": "Page1_JSInit.init",
  "name": "JSInit.init",
  "collectionId": "Page1_JSInit",
  "confirmBeforeExecute": false,
  "pluginType": "JS",
  "jsonPathKeys": [],
  "timeoutInMillisecond": 10000
}
```

Key differences from API actions:
- `pluginType`: `"JS"` (not `"API"`)
- `name`: `JSObjectName.functionName`
- `collectionId`: `PageId_JSObjectName`

## API Response Structure

REST API controllers use `result.getXxx()` which returns the DTO **directly**, not the wrapper:

| Endpoint | Access Pattern |
|----------|----------------|
| `/dashboard/kpis` | `api.data?.totalProcesses` |
| `/step/form-kpis` | `api.data?.withFormKpis?.avgElapsedTime` |
| `/user/ranking` | `api.data?.users` |
| `/instance/ranking` | `api.data?.items` |
| `/step/ranking` | `api.data?.items` |
| `/users/current` | `api.data?.user_name` |

### Why Direct Access

```java
// In the REST API controller:
return Utils.jsonResponse(responseBuilder, MAPPER, SC_OK, result.getDashboardKpis());
// Returns DashboardKpisDTO content directly, NOT ResultDashboardKpis wrapper
```

### Correct Bindings

```javascript
// Dashboard KPIs - direct access
"{{getDashboardKpis.data?.totalProcesses}}"
"{{getDashboardKpis.data?.avgInstanceElapsedTime}}"

// Form KPIs - direct access
"{{getFormKpis.data?.withFormKpis?.avgElapsedTime}}"
"{{getFormKpis.data?.totalFormSteps}}"

// User data - direct access
"{{userQuery.data?.user_name}}"
"{{userQuery.data?.menu}}"
```

## Dynamic Query Parameters

Use mustache syntax in query parameters for dynamic values:

```json
"queryParameters": [
  {"key": "processId", "value": "{{appsmith.store.selectedProcessId}}"},
  {"key": "page", "value": "{{Table1.pageNo}}"},
  {"key": "size", "value": "10"}
]
```

Add the parameter paths to `dynamicBindingPathList`:

```json
"dynamicBindingPathList": [
  {"key": "queryParameters.param1.value"}
]
```

## POST Request with Body

For POST requests, set the body and appropriate content type:

```json
{
  "httpMethod": "POST",
  "body": "{{JSON.stringify({field1: Input1.text, field2: Select1.selectedOptionValue})}}",
  "formData": {"apiContentType": "application/json"},
  "dynamicBindingPathList": [
    {"key": "body"}
  ]
}
```
